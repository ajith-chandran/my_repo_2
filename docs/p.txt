Below is a **complete production-ready plan** for deploying a **GraphQL Mesh Supergraph** (with schema stitching and/or federation), handling **internal + per-subgraph Bearer tokens**, securing secrets, and building a full **CI/CD workflow** suitable for real-world Node.js deployments.

Everything is specific to **Node.js + Mesh** and follows modern infra/security standards.

---

# ‚úÖ **1. Production Architecture Overview**

```
Clients ‚Üí Mesh Gateway ‚Üí Subgraph Microservices (REST/GraphQL)
          |
          +‚Üí AuthN/AuthZ
          +‚Üí Token handling
          +‚Üí Caching, rate limits
```

Mesh Gateway Responsibilities:

* Acts as a **single unified entry point**.
* Controls **authentication** for incoming requests.
* Adds **internal service-to-service tokens** for each subgraph.
* Performs **schema composition** and **stitching/federation**.
* Runs inside **Node.js** as a deployable HTTP server.
* Should be containerized (Docker/K8s).

---

# ‚úÖ **2. Production Deployment Goals**

| Requirement                    | Description                                                        |
| ------------------------------ | ------------------------------------------------------------------ |
| Secure main gateway token      | Validate incoming auth header (JWT or API Key)                     |
| Secure per-subgraph tokens     | Each microservice gets its own internal bearer token               |
| Store secrets securely         | NOT in mesh.yaml, but injected using environment variables / vault |
| Convert Mesh to Node.js server | Use `@graphql-mesh/runtime` + `@graphql-mesh/http`                 |
| Use build pipeline             | Build ‚Üí Test ‚Üí Bundle ‚Üí Docker ‚Üí Push ‚Üí Deploy                     |
| Use CI/CD                      | GitHub Actions, GitLab CI, Azure DevOps                            |
| Configurable environments      | dev/stage/prod env vars & mesh config rewriting                    |

---

# ‚úÖ **3. Refactoring `mesh.yaml` for Production**

### ‚ùå Avoid storing tokens in mesh.yaml

Instead of:

```yaml
sources:
  - name: users
    handler:
      graphql:
        endpoint: https://users.service/graphql
        headers:
          Authorization: "Bearer hard-coded-token"
```

### ‚úÖ Use environment variables

```yaml
sources:
  - name: users
    handler:
      graphql:
        endpoint: ${USER_SERVICE_URL}
        headers:
          Authorization: "Bearer ${USER_SERVICE_TOKEN}"
```

### üëâ You will supply these in `process.env` at runtime.

---

# ‚úÖ **4. Implement Authentication Logic in Node.js (NOT in YAML)**

Create your Mesh server:

### **server.js**

```js
import { createMeshHTTPHandler } from '@graphql-mesh/http';
import { getBuiltMesh } from './.mesh';

const PORT = process.env.PORT || 4000;
const MAIN_TOKEN = process.env.MESH_MAIN_TOKEN;

async function main() {
  const mesh = await getBuiltMesh();
  
  const handler = createMeshHTTPHandler({
    baseDir: process.cwd(),
    getBuiltMesh: () => mesh,
    async onRequest({ req, request, fetchAPI }) {
      // Validate main token
      const incomingToken = req.headers['authorization']?.replace('Bearer ', '');
      if (incomingToken !== MAIN_TOKEN) {
        return new fetchAPI.Response(JSON.stringify({ error: 'Unauthorized' }), {
          status: 401
        });
      }
    }
  });

  require('http')
    .createServer(handler)
    .listen(PORT, () => console.log(`Mesh running on port ${PORT}`));
}

main();
```

### This gives you:

* Centralized **gateway authentication**
* Ability to add **rate limit**, **RBAC**, **logging**, etc.

---

# ‚úÖ **5. Injecting Subgraph Bearer Tokens Securely**

### `mesh.yaml`

```yaml
sources:
  - name: orders
    handler:
      rest:
        endpoint: ${ORDERS_URL}
        headers:
          Authorization: "Bearer ${ORDERS_SERVICE_TOKEN}"
```

### Run in production:

```
export ORDERS_SERVICE_TOKEN=$(vault read ...)
export MESH_MAIN_TOKEN="abcd1234"
node server.js
```

Or in Docker:

```
docker run -e ORDERS_SERVICE_TOKEN=xxxx -e MESH_MAIN_TOKEN=xxxx my-mesh
```

---

# ‚úÖ **6. Handling Security Keys (Best Practices)**

| What             | Best Practice                                               |
| ---------------- | ----------------------------------------------------------- |
| API keys         | Use HashiCorp Vault or AWS Secrets Manager                  |
| JWT signing keys | Use KMS-managed keys                                        |
| Subgraph tokens  | Per-service tokens, rotated regularly                       |
| TLS              | Always enforce HTTPS on all services                        |
| Logging tokens   | NEVER log secrets                                           |
| Gateway headers  | Remove sensitive internal headers before sending to clients |

---

# ‚úÖ **7. Use Env Separation for Multiple Environments**

### Example `.env.production`

```
USER_SERVICE_URL=https://prod.users/api
USER_SERVICE_TOKEN=prod-secret
MESH_MAIN_TOKEN=prod-main-token
```

### `.env.staging`

```
USER_SERVICE_URL=https://stage.users/api
USER_SERVICE_TOKEN=stage-secret
MESH_MAIN_TOKEN=stage-main-token
```

Load environment from CI/CD during deployment.

---

# ‚úÖ **8. Dockerizing the Mesh Server**

### **Dockerfile**

```Dockerfile
FROM node:20-slim

WORKDIR /app

COPY package*.json ./
RUN npm install --omit=dev

COPY . .

RUN npm run mesh:build

EXPOSE 4000

CMD ["node", "server.js"]
```

### Build & Push

```
docker build -t myorg/mesh-gateway:1.0 .
docker push myorg/mesh-gateway:1.0
```

---

# ‚úÖ **9. Production Deployment Options**

### If using Kubernetes:

* Deploy as a Deployment
* ConfigMaps for mesh.yaml / schema
* Secrets for tokens
* HorizontalPodAutoscaler for load

### Example Kubernetes secret:

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: mesh-secrets
type: Opaque
data:
  MESH_MAIN_TOKEN: <base64>
  USER_SERVICE_TOKEN: <base64>
```

---

# ‚úÖ **10. CI/CD Pipeline (GitHub Actions Example)**

### `.github/workflows/deploy.yml`

```yaml
name: Deploy Mesh Gateway

on:
  push:
    branches: ["main"]

jobs:
  build-deploy:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node
        uses: actions/setup-node@v3
        with:
          node-version: 20

      - name: Install Dependencies
        run: npm ci
      
      - name: Run Lint & Tests
        run: npm test

      - name: Build Mesh Artifacts
        run: npm run mesh:build

      - name: Docker Build
        run: docker build -t myorg/mesh-gateway:${{ github.sha }} .

      - name: Push Docker
        run: |
          echo $CR_PAT | docker login ghcr.io -u USER --password-stdin
          docker tag myorg/mesh-gateway:${{ github.sha }} ghcr.io/myorg/mesh-gateway:${{ github.sha }}
          docker push ghcr.io/myorg/mesh-gateway:${{ github.sha }}

      - name: Deploy to Kubernetes
        run: kubectl apply -f k8s/mesh-gateway.yaml
```

---

# ‚úÖ **11. Security Best Practices Summary**

### üîê Authentication

* Validate incoming tokens in Node.js (`server.js`)
* Reject unauthenticated callers early

### üîê Authorization

Mesh can integrate with:

* RBAC in gateway
* Policy engines like **OPA** (optional)

### üîê Secrets Management

* Store no secrets in Git
* Use environment variables or secrets manager
* Rotate microservice tokens every 30‚Äì90 days

### üîê Hardening

* Enable **Helmet** (Node.js security)
* Enable **rate-limiting** in gateway
* Apply **CORS restrictions**
* Enforce **TLS**

---

# ‚úÖ **12. Final Checklist Before Production**

| Area            | Checks                          |
| --------------- | ------------------------------- |
| ‚úî Config        | mesh.yaml uses env vars         |
| ‚úî Secrets       | Linked from secrets manager     |
| ‚úî CI            | Mesh build ‚Üí test ‚Üí docker      |
| ‚úî CD            | Push ‚Üí deploy                   |
| ‚úî Security      | Env separation, secret rotation |
| ‚úî Observability | Add logs, metrics, and tracing  |

---

# If you want, I can also generate:

‚úÖ A **full folder structure** for the project
‚úÖ A **complete production K8s manifest**
‚úÖ A **secure Vault integration example**
‚úÖ A **better custom auth middleware with JWT**
‚úÖ A **Mesh plugin to dynamically inject tokens per-request**

Just tell me and I‚Äôll generate those too.
