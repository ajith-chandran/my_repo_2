# Federation directives
directive @key(fields: String!) repeatable on OBJECT | INTERFACE
directive @external on FIELD_DEFINITION
directive @extends on OBJECT | INTERFACE

type Order {
  id: ID!
  product: String!
  userId: ID!
}

type Query {
  getOrders(criteria: String!): [Order]
}

# Extend User type for federation
extend type User @key(fields: "id") {
  id: ID! @external
  orders: [Order]
}


-----


package com.example.orders.federation;

import java.util.Map;

public interface EntityResolver {
    boolean supports(String typeName);
    Object resolve(Map<String, Object> reference);
}


-----

package com.example.orders.federation;

import org.springframework.stereotype.Component;
import java.util.List;
import java.util.Map;

@Component
public class EntityResolverRegistry {
    private final List<EntityResolver> resolvers;

    public EntityResolverRegistry(List<EntityResolver> resolvers) {
        this.resolvers = resolvers;
    }

    public Object resolveEntity(Map<String, Object> reference) {
        String typeName = (String) reference.get("__typename");
        return resolvers.stream()
                .filter(r -> r.supports(typeName))
                .findFirst()
                .map(r -> r.resolve(reference))
                .orElse(null);
    }
}


---


package com.example.orders.federation;

import com.example.orders.model.User;
import org.springframework.stereotype.Component;
import java.util.Map;

@Component
public class UserEntityResolver implements EntityResolver {

    @Override
    public boolean supports(String typeName) {
        return "User".equals(typeName);
    }

    @Override
    public Object resolve(Map<String, Object> reference) {
        String id = (String) reference.get("id");
        return new User(id);
    }
}


---


package com.example.orders.fetchers;

import graphql.schema.DataFetcher;
import graphql.schema.DataFetchingEnvironment;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import com.example.orders.service.OrderService;
import com.example.orders.model.Order;
import java.util.List;
import java.util.Map;

@Component
public class UserOrdersDataFetcher implements DataFetcher<List<Order>> {

    @Autowired
    private OrderService orderService;

    @Override
    public List<Order> get(DataFetchingEnvironment env) {
        Map<String, Object> user = env.getSource();
        String userId = (String) user.get("id");
        return orderService.getOrders("accountNumber:" + userId);
    }
}



----

package com.example.orders;

import com.apollographql.federation.graphqljava.Federation;
import com.example.orders.federation.EntityResolverRegistry;
import com.example.orders.fetchers.*;
import graphql.GraphQL;
import graphql.schema.GraphQLSchema;
import graphql.schema.idl.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import javax.annotation.PostConstruct;
import java.io.File;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Service
public class GraphQLServiceImplementation {

    @Autowired private OrderListDataFetcher orderListDataFetcher;
    @Autowired private OrderDataFetcher orderDataFetcher;
    @Autowired private OrderCountDataFetcher orderCountDataFetcher;
    @Autowired private CustomerDataFetcher customerDataFetcher;
    @Autowired private OrderLookUpDataFetcher orderLookUpDataFetcher;
    @Autowired private UserOrdersDataFetcher userOrdersDataFetcher; // ðŸ‘ˆ new for User.orders
    @Autowired private EntityResolverRegistry entityRegistry;       // ðŸ‘ˆ dynamic federation registry

    @Autowired(required = false)
    private CustomQueryDirective customQueryDirective;              // your existing instrumentation

    private GraphQL graphQL;

    @PostConstruct
    public void loadSchema() throws Exception {
        File schemaFile = new File("src/main/resources/graphql/order.graphqls");

        // Parse .graphqls file
        TypeDefinitionRegistry typeRegistry = new SchemaParser().parse(schemaFile);

        // Build all data fetchers
        RuntimeWiring runtimeWiring = buildRuntimeWiring();

        // Wrap with Apollo Federation
        GraphQLSchema schema = Federation.transform(typeRegistry, runtimeWiring)
            // Handles _entities requests dynamically via registry
            .fetchEntities(env -> {
                List<Map<String, Object>> reps = env.getArgument("representations");
                return reps.stream()
                        .map(entityRegistry::resolveEntity)
                        .collect(Collectors.toList());
            })
            // Dynamically resolve entity type from object
            .resolveEntityType(env -> {
                Object src = env.getObject();
                if (src == null) return null;
                String typeName = src.getClass().getSimpleName();
                return env.getSchema().getObjectType(typeName);
            })
            .build();

        // Preserve your existing custom directive addition (includeIf)
        schema = schema.transform(builder ->
            builder.additionalDirective(schema.getDirective("includeIf"))
        );

        // Build final GraphQL engine with your existing settings
        this.graphQL = GraphQL.newGraphQL(schema)
            .fieldVisibility(getOrderFieldVisibility()) // from your existing code
            .instrumentation(customQueryDirective)      // from your existing code
            .build();
    }

    private RuntimeWiring buildRuntimeWiring() {
        return RuntimeWiring.newRuntimeWiring()
            // Your existing Query mappings
            .type("Query", builder -> builder
                .dataFetcher("getOrders", orderListDataFetcher)
                .dataFetcher("getOrderData", orderDataFetcher)
                .dataFetcher("countOrders", orderCountDataFetcher)
                .dataFetcher("getCustomerByAccount", customerDataFetcher)
                .dataFetcher("orderLookup", orderLookUpDataFetcher)
            )
            // New federated field resolver for User.orders
            .type("User", builder -> builder
                .dataFetcher("orders", userOrdersDataFetcher)
            )
            .fieldVisibility(getOrderFieldVisibility())
            .build();
    }

    // Your existing method
    private graphql.schema.visibility.GraphqlFieldVisibility getOrderFieldVisibility() {
        // Assuming this method already exists in your class, preserve it.
        // You might have your own implementation or bean.
        return graphql.schema.visibility.DefaultGraphqlFieldVisibility.DEFAULT_FIELD_VISIBILITY;
    }

    public GraphQL getGraphQL() {
        return graphQL;
    }
}

----


package com.example.orders.model;

public class User {
    private String id;
    public User(String id) { this.id = id; }
    public String getId() { return id; }
}


----



public class FederationDirectives {
    public static void registerFederationDirectives(TypeDefinitionRegistry registry) {
        String federationSDL = """
            directive @key(fields: String!) repeatable on OBJECT | INTERFACE
            directive @external on FIELD_DEFINITION
            directive @requires(fields: String!) on FIELD_DEFINITION
            directive @provides(fields: String!) on FIELD_DEFINITION
            directive @extends on OBJECT | INTERFACE
        """;
        TypeDefinitionRegistry federationRegistry = new SchemaParser().parse(federationSDL);
        registry.merge(federationRegistry);
    }
}

---


@Configuration
public class FederationConfig {

    @Bean
    public GraphQLSchema federatedSchema(GraphQLSchema originalSchema) {
        return Federation.transform(originalSchema)
                .fetchEntities(env -> env.getRepresentations().stream()
                        .map(repr -> {
                            if ("User".equals(repr.get("__typename"))) {
                                return new User((String) repr.get("id"));
                            }
                            return null;
                        })
                        .toList())
                .resolveEntityType(env -> {
                    Object src = env.getObject();
                    if (src instanceof User) {
                        return env.getSchema().getObjectType("User");
                    }
                    return null;
                })
                .build();
    }
}


----


@PostConstruct
public void loadSchema() {
    TypeDefinitionRegistry typeRegistry = new SchemaParser().parse(new File(graphQLPath));

    RuntimeWiring runtimeWiring = buildRuntimeWiring();

    // Wrap with Apollo Federation
    GraphQLSchema schema = Federation.transform(typeRegistry, runtimeWiring)
            // Handles _entities requests dynamically
            .fetchEntities(env -> {
                List<Map<String, Object>> representations = env.getArgument("representations");

                return representations.stream()
                        .map(repr -> {
                            String typename = (String) repr.get("__typename");
                            if ("User".equals(typename)) {
                                return new User((String) repr.get("id"));
                            }
                            return null;
                        })
                        .collect(Collectors.toList());
            })
            .resolveEntityType(env -> {
                Object src = env.getObject();
                if (src instanceof User) {
                    return env.getSchema().getObjectType("User");
                }
                return null;
            })
            .build();

    // Add custom directives if needed
    GraphQLSchema finalSchema = schema_transform(builder -> {
        builder.additionalDirective(finalSchema.getDirective("includeIf"));
    });
}